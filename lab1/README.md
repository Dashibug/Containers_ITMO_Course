Плохой докер файл
- Используется базовый образ ubuntu:latest, то есть непонятная версия и очень тяжёлый образ.
- Все команды выполняются под root-пользователем.
- Много лишних слоёв и пакетов: apt-get update и apt-get install разделены, ставятся git/vim/nano, кэш apt не чистится - итоговый образ весит много.
- Используется COPY . /app - в контейнер попадает весь контекст (включая .git, временные файлы и т.п.).
- Зависимости ставятся через pip install flask без requirements.txt и фиксированных версий - сложно воспроизводить окружение.

Хороший докер файл
- Используется лёгкий и фиксированный образ python:3.11-slim - понятная версия.
- Пакеты устанавливаются под root, затем создаётся и используется пользователь appuser - так получается безопаснее.
- Слои с установкой зависимостей скомпанованы и кэшируются (сначала requirements.txt, потом код) - быстрее сборка и меньше слоёв.
- Python-зависимости вынесены в отдельный файл requirements.txt с фиксированными версиями - окружение проще обновлять и воспроизводить.
- Определён volume VOLUME ["/data"] и порт через EXPOSE 8000 - данные приложения выносятся наружу, а порт явно прописан.

---

## Плохие практики использования этого контейнера

1. **Запуск без примонтированного volume `/data`.**  
   Контейнер объявляет `VOLUME ["/data"]`, но если стартовать его просто так, без `-v`/`--mount`, все данные окажутся только внутри файловой системы контейнера.  
   При пересоздании контейнера (обновление образа, `docker rm` и т.п.) данные потеряются.

2. **Использовать один контейнер как «мультисервис»**  
   Плохой вариант - дописывать в этот образ ещё кучу сервисов (cron, nginx, БД и т.д.) и запускать всё внутри одного контейнера.  
   Так становится сложно обновлять и отлаживать отдельные части, нельзя нормально масштабировать приложение по отдельным сервисам и нарушается идея «один контейнер - один процесс».

---

## Когда контейнеры использовать не стоит

1. **Очень простые одноразовые скрипты на одном сервере.**  
   Если нужно один раз запустить небольшой скрипт на своей машине, городить Docker-образ и оркестрацию - избыточно.  
   Проще выполнить скрипт напрямую в системе или в обычном virtualenv.

2. **Приложения, которым нужна виртуализация и полный контроль над ядром.**  
   Например, низкоуровневые системные сервисы, драйверы, специфичные сетевые/firewall-решения.  
   Для такого лучше подходят полноценные виртуальные машины, а не контейнеры, потому что контейнеры делят одно ядро и не дают такой же степени изоляции.



