## Архитектура
Проект состоит из трёх сервисов:

---

### 1. **db** — база данных PostgreSQL
- **Образ:** `postgres:16-alpine`
- **Назначение:** хранение данных приложения (таблицы `init_log`, `ping` и т.п.)
- **Порт:** `5432` (используется внутри docker-сети, наружу не пробрасывается)
- **Особенности:**
  - Настроен `healthcheck` на базе команды `pg_isready`, чтобы другие сервисы ждали готовности БД
  - Данные сохраняются в именованный volume `pg_data:/var/lib/postgresql/data`
  - Все параметры подключения (пользователь, пароль, имя БД) подставляются из файла `.env`

---

### 2. **init** — init-контейнер
- **Образ:** `lab2_app:1.0`  
  (собирается из `lab1/Dockerfile.good` — того же Dockerfile, что использовался в ЛР1)
- **Назначение:** однажды инициализировать базу данных:
  - подключиться к PostgreSQL
  - создать таблицу `init_log`, если её ещё нет
  - добавить в неё запись
- **Команда:** `python init_db.py`
- **Особенности:**
  - Сборка идёт из корня проекта (`context: ..`), чтобы были доступны `app/` и Dockerfile из `lab1`
  - Запускается только после того, как `db` перешёл в состояние `healthy`  
    (`depends_on: db: condition: service_healthy`)
  - Использует те же переменные окружения и volume `app_data`, что и основной сервис
  - Выполняется один раз: после успешного завершения контейнер остаётся в статусе `exited` и не перезапускается (по умолчанию `restart: "no"`)

---

### 3. **app** — основное веб-приложение
- **Образ:** `lab2_app:1.0` (тот же, что у `init`, из `lab1/Dockerfile.good`)
- **Назначение:** простое Flask-приложение с двумя эндпоинтами:
  - `GET /` — базовая проверка «приложение запущено»
  - `GET /db-ping` — подключается к БД по `DATABASE_URL`, создаёт таблицу `ping` (если нет) и пишет туда запись
- **Порт:** `8000` внутри контейнера, наружу пробрасывается как `${APP_PORT}:8000`
- **Особенности:**
  - Получает строку подключения к БД из переменной `DATABASE_URL` (файл `.env`)
  - Запускается только после:
    - готовности БД (`db: condition: service_healthy`)
    - успешного завершения init-контейнера (`init: condition: service_completed_successfully`)
  - Использует именованный volume `app_data:/data` для хранения данных приложения
  - Имеет `healthcheck`, который проверяет доступность порта 8000 внутри контейнера  
    (через попытку TCP-подключения)

---

## Volumes

Используются два именованных volume:

- **`pg_data`** — хранит данные PostgreSQL  
  Монтируется в контейнер `db` по пути `/var/lib/postgresql/data`.
- **`app_data`** — хранит данные приложения  
  Монтируется в контейнеры `init` и `app` по пути `/data` (соответствует `VOLUME ["/data"]` из Dockerfile “хорошей” ЛР1).

Таким образом, данные БД и приложения не теряются при пересоздании контейнеров.

---

## Network

Все сервисы подключены к единой сети:

- **Сеть:** `lab2_net` (driver `bridge`)

Это даёт:

- изоляцию от остальных контейнеров Docker на машине;
- возможность обращаться к сервисам по их именам (`db`, `init`, `app`) внутри сети.

---

## Переменные окружения

Все переменные окружения вынесены в файл `.env` в папке `lab2`:

```env
APP_PORT=8000

POSTGRES_USER=postgres
POSTGRES_PASSWORD=postgres
POSTGRES_DB=appdb

DATABASE_URL=postgresql://postgres:postgres@db:5432/appdb
```

## Запуск проекта
cd lab2

### 1. Собрать образ и запустить все сервисы
docker compose up --build

### 2. Смотреть логи
docker compose logs -f

### 3. Открыть веб-приложение

#### http://localhost:${APP_PORT}/
#### проверка работы с базой данных
#### http://localhost:${APP_PORT}/db-ping

## Ответы на вопросы

### 1. Можно ли ограничивать ресурсы (например, память или CPU) для сервисов в docker-compose.yml? Если нет, то почему, если да, то как?

Ответ: Да, в docker-compose.yml можно описывать ограничения ресурсов для сервисов. Это делается в секции deploy.resources:
```
services:
  web:
    image: nginx:alpine
    ports:
      - "8080:80"
    deploy:
      resources:
        limits:
          cpus: "0.5"    # жёсткий предел по CPU
          memory: 512M   # жёсткий предел по памяти
        reservations:
          cpus: "0.25"   # гарантированный минимум CPU
          memory: 256M   # гарантированный минимум памяти
```

- limits — жёсткие границы: выше указанных значений контейнер не должен подниматься.
- reservations — “гарантированные” ресурсы, которые учитываются планировщиком при размещении контейнеров.

### 2. Как можно запустить только определённый сервис из docker-compose.yml, не запуская остальные?

Ответ: Docker Compose позволяет запускать конкретные сервисы по имени:

- Запуск только одного сервиса (с его зависимостями):
```
docker compose up app
```
В этом случае Compose поднимет сервис app и, если нужно, его зависимости, указанные в depends_on.

- Запуск конкретного сервиса без зависимостей:
```
docker compose up --no-deps db
```

Здесь поднимется только сервис db, а зависимости для него запускаться не будут.

- Одноразовый запуск команды на основе сервиса (без фонового режима):
```
docker compose run --rm app bash
```
